\chapter{Introduction}

This disertation will explore the use of a unit testing technique
called ``dependency mocking'' in the strongly, statically typed
functionl programming language OCaml. Mocking (or object mocking, as
it is more commonly known) is method of replacing hard-to-test
dependencies in object-oriented code with automatically generated
objects in order to make it easier to write unit tests. The technique
was first applied for use in Java, which is an object oriented
langauge with static types and run-time instrumentation
facilities.

This disertation will describe the current state-of-the-art in unit
testing, specifically as it applies to functional programming
languages similar to OCaml (XXX just cover the thesis' organisation
here).

The dissertation is organised as follows. (XXX And fill this out
later)

\section{Motivation of this dissertation}

%% We want to show why it is important to test software

%% Why is testing important? Include the statistic about how expensive
%% bugs are to fix after code has been shipped.

Testing is an important part of software development. XXX study showed
that the average cost of fixing a bug in production is an order of
magnitude greater than the cost of fixing it pre-production (cite
needed!).

% testing versus static type checking



%% Much of the below is lifted from the proposal. I need to chop out
%% some stuff that's not necessary here, and beef up the parts that
%% are.

% types of tests. probably don't need this?

Software tests are often categorised as either system, component, or
unit tests. These categories represent a spectrum of
granularity. Systems tests represent the broadest granularity, and are
meant to test the entire system as a whole. On the other end of the
spectrum are unit tests, which test functionality at the finest level
of granularity: typically a method or function. Component tests sit
somewhere in between the two ends of the spectrum, and might test
interactions between modules or classes of an application, or perhaps
the interaction between a web server and a database. A system test may
require a test environment that is an exact replica of the production
system, whereas a unit test may be run on the developer's workstation
each time the software is rebuilt.

Recent trends in Agile development, such as continuous integration
\cite{humble:continuous} and test driven development \cite{beck:tdd},
have placed a greater emphasis on unit testing. Consequentially, many
tools and libraries have been developed to assist programmers in
writing these tests. Many of these libraries, such as JUnit
\cite{www:junit} for Java, NUnit \cite{www:nunit} for .NET, and OUnit
\cite{www:ounit} for OCaml, follow the xUnit patterns of test
development described by Meszaros \cite{meszaros:xunit}. This family
of libraries typically provides a set of convenient assertion
functions to help the user write test cases, annotations to help
organise these test cases into larger test suites, and test harnesses
to handle test running and status reporting.

A common problem with writing unit tests is that, for various reasons,
some code is just hard to test. This is often the case when the
depended-on component (DOC) of the system under test (SUT) performs
some side-effecting operation that is not valid in the test scenario,
or is otherwise impossible to run from within the test
harness.

\section{Objectives and expected contribution}
